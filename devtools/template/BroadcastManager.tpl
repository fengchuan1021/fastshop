#dont modify this file,it is autogenerated.for IDE vscode's type hint list all broadcast with annotations
# no bad affect on efficiency,will be ignored by python runtime
from collections.abc import Callable
from fastapi import BackgroundTasks
from typing import Type,Any,TypeVar,Generic,List
import asyncio
import Models
from Models import Base
from pydantic import  BaseModel
INDATATYPE=Type[BaseModel]
from sqlalchemy.ext.asyncio import AsyncSession
Model= TypeVar("Model", bound=Base)
class BroadcastManager():

    def __init__(self):
        self.broadcastqueue={}
        #self.loop = asyncio.get_event_loop()
        #print('loopid:',id(self.loop))
#    def BeforeModelUpdated(self,listenModel : Type[Model]):
#
#        def decorator(func):
#            queuename=f'Before{listenModel.__name__}Updated'
#            if queuename not in self.broadcastqueue:
#                self.broadcastqueue[queuename]=[]
#            self.broadcastqueue[queuename].append(func)
#        return decorator
#    def AfterModelUpdated(self,listenModel : Type[Model]):
#
#        def decorator(func):
#            queuename=f'After{listenModel.__name__}Updated'
#            if queuename not in self.broadcastqueue:
#                self.broadcastqueue[queuename]=[]
#            self.broadcastqueue[queuename].append(func)
#        return decorator
    def BeforeModelCreated(self,listenModel : Type[Model]):
        def decorator(func ):
            queuename=f'Before{listenModel.__name__}Created'
            if queuename not in self.broadcastqueue:
                self.broadcastqueue[queuename]=[]
            self.broadcastqueue[queuename].append(func)
        return decorator
    def AfterModelCreated(self,listenModel : Type[Model]):
        def decorator(func):
            queuename=f'After{listenModel.__name__}Created'
            if queuename not in self.broadcastqueue:
                self.broadcastqueue[queuename]=[]
            self.broadcastqueue[queuename].append(func)
        return decorator
#    def fireBeforeUpdated(self,fireModel : Type[Model],oldmodel:Model,newmodel:Model,db: AsyncSession,token,reason:str=''):
#        name=f'Before{fireModel.__name__}Updated'
#        if name in self.broadcastqueue:
#            for func in self.broadcastqueue[name]:
#                if asyncio.iscoroutinefunction(func):
#                    self.loop.create_task(oldmodel,newmodel,db,token,reason)
#                else:
#                    raise Exception("call back must be a async function")
#                    #self.loop.run_in_executor(None, func,oldmodel,newmodel,db,token,reason)

    def BeforeCreated(self,newmodel:Model,db: AsyncSession,token,reason:Any=None):
        name=f'Before{newmodel.__class__.__name__}Created'
        loop=asyncio.get_event_loop()
        if name in self.broadcastqueue:
            pass
            #for func in self.broadcastqueue[name]:
                #if asyncio.iscoroutinefunction(func):
                    #loop.run_until_complete(func(newmodel,db,token,reason))
                    #ret=await func(newmodel,db,token,reason)
                    #if ret:
                    #    return ret
                #else:
                    #raise Exception("call back must be a async function")
                    #func(newmodel,db,token,reason)
                    #self.loop.run_in_executor(None, func,newmodel,db,token,reason)

#    def fireAfterUpdated(self,fireModel : Type[Model],oldmodel:Model,newmodel:Model,db: AsyncSession,token,reason:str=''):
#        name=f'After{fireModel.__name__}Updated'
#        if name in self.broadcastqueue:
#            for func in self.broadcastqueue[name]:
#                if asyncio.iscoroutinefunction(func):
#                    self.loop.create_task(oldmodel,newmodel,db,token,reason)
#                else:
#                    raise Exception("call back must be a async function")
#                    #self.loop.run_in_executor(None, func,oldmodel,newmodel,db,token,reason)

    async def fireAfterCreated(self,newmodels:List[Model],db: AsyncSession,token):
        for model in newmodels:
            name=f'After{model.__class__.__name__}Created'
            if name in self.broadcastqueue:
                for func in self.broadcastqueue[name]:
                    if asyncio.iscoroutinefunction(func):
                        await func(model,db,token)
                    else:
                        raise Exception("call back must be a async function")
                        #self.loop.run_in_executor(None, func,newmodel,db,token,reason)

    def createfunction(self,funcname:str):
        def inner(inDataType):
            if callable(inDataType):
                self.broadcastqueue[funcname].append(inDataType)
            else:

                if funcname in self.broadcastqueue:
                    for func in self.broadcastqueue[funcname]:

                        if asyncio.iscoroutinefunction(func):
                            self.loop.create_task(func(inDataType))
                            #await func(inDataType)
                        else:
                            self.loop.run_in_executor(None, func, inDataType)
                        #background_tasks.add_task(func,inDataType)
                else:
                    raise ('broadcast not registered')
        return inner
    def createBroadcast(self,broadcastname,indatatype:INDATATYPE=None):
        if broadcastname not in self.broadcastqueue:
            self.broadcastqueue[broadcastname]=[]
            tmpfunc=self.createfunction(broadcastname)
            setattr(self,broadcastname,tmpfunc)
            return tmpfunc
        else:
            raise ("broadcast had been registered")


broadcastManager=BroadcastManager()
